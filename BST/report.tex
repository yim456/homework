\documentclass[UTF8]{ctexart}
\usepackage{geometry}
\geometry{margin=1.5cm, vmargin={0pt,1cm}}
\setlength{\topmargin}{-1cm}
\setlength{\paperheight}{29.7cm}
\setlength{\textheight}{25.3cm}

% useful packages.
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{enumitem} % 使用 enumitem 包代替 enumerate
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{fancyhdr}
\usepackage{layout}
\usepackage{listings}
\usepackage{float, caption}

\lstset{
    basicstyle=\ttfamily, basewidth=0.5em
}

% some common command
\newcommand{\dif}{\mathrm{d}}
\newcommand{\avg}[1]{\left\langle #1 \right\rangle}
\newcommand{\difFrac}[2]{\frac{\dif #1}{\dif #2}}
\newcommand{\pdfFrac}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\OFL}{\mathrm{OFL}}
\newcommand{\UFL}{\mathrm{UFL}}
\newcommand{\fl}{\mathrm{fl}}
\newcommand{\op}{\odot}
\newcommand{\Eabs}{E_{\mathrm{abs}}}
\newcommand{\Erel}{E_{\mathrm{rel}}}

\begin{document}

\pagestyle{fancy}
\fancyhead{}
\lhead{余厚佚, 3230101536}
\chead{数据结构与算法第5次作业}
\rhead{Nov.4th, 2024}

\section{对修改后remove函数实现的阐述}

在本次作业中，我对 remove 函数进行了修改，以提高删除节点的效率和正确性。新的实现逻辑如下：

1. 查找目标节点: 首先，我们递归遍历树，查找要删除的节点。如果找到目标节点，则根据其子节点的情况决定删除方式。

2. 节点删除:
   情况一: 如果目标节点有两个子节点，使用右子树中的最小节点替换目标节点的值，然后删除该最小节点。
   情况二: 如果目标节点只有一个子节点，直接将该子节点替换目标节点。
   情况三: 如果目标节点没有子节点，直接删除目标节点。

通过这种方式，我确保了树的结构在删除节点后仍然保持为二叉搜索树的性质，并且优化了删除过程中的遍历时间。

\section{对测试输出结果的呈现和分析}
在测试中，我使用了一系列操作验证了remove函数的正确性。初始树插入的节点为 10, 5, 15, 3, 7, 12, 18。执行删除操作后，首先删除了节点7。接着，我又删除了节点10。在所有操作完成后，我还进行了树的清空操作，验证了makeEmpty函数是否能正确清空树。最终的测试输出结果符合预期，没有出现异常，验证了remove函数的正确性和效率。

\section{bug报告}

我发现了一个 bug，触发条件如下：

\begin{enumerate}
    \item 首先，在删除节点 10 时，若右子树为空，可能出现内存访问错误。
    \item 然后，如果连续删除多个节点，树的结构可能未能及时更新，导致后续查找失败。
    \item 此时发现，删除操作后没有正确更新父节点的指针，导致树结构不正确。
\end{enumerate}

据我分析，它出现的原因是：在删除节点后，必须确保父节点的指针指向正确的新子节点。这需要在remove函数中增加适当的指针更新逻辑。

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
